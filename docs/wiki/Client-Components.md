# Client Components

Detailed documentation of the WebAssembly client architecture, including rendering, WebSocket communication, and browser integration.

## Table of Contents
- [Overview](#overview)
- [Architecture](#architecture)
- [Core Modules](#core-modules)
- [WebGL Rendering](#webgl-rendering)
- [Browser Integration](#browser-integration)

## Overview

The client is a Rust library compiled to **WebAssembly** (WASM) that runs in the browser. It handles:
- WebSocket communication with the server
- WebGL-based particle rendering
- User input processing
- State management

```mermaid
graph TB
    subgraph "Browser Environment"
        subgraph "WASM Module (Rust)"
            Client[Client Struct]
            Renderer[Renderer]
            WSClient[WebSocket Client]
        end

        subgraph "JavaScript Layer"
            UI[UI Controls]
            JSGlue[JS Glue Code]
            Callbacks[Event Callbacks]
        end

        subgraph "Browser APIs"
            WebGL[WebGL Context]
            WSApi[WebSocket API]
            Canvas[Canvas Element]
        end
    end

    UI -->|User Events| JSGlue
    JSGlue -->|Call WASM| Client
    Client -->|Manage| WSClient
    Client -->|Manage| Renderer
    WSClient -->|Use| WSApi
    Renderer -->|Use| WebGL
    Renderer -->|Draw to| Canvas

    style Client fill:#e1f5ff
    style Renderer fill:#b3e5fc
    style WSClient fill:#81d4fa
    style UI fill:#c8e6c9
    style JSGlue fill:#a5d6a7
    style WebGL fill:#fff59d
```

## Architecture

### Module Structure

```
client/
├── src/
│   ├── lib.rs           # Client entry point and WebSocket handling
│   ├── renderer.rs      # WebGL rendering engine
│   └── shaders/
│       ├── vertex.glsl      # Vertex shader
│       └── fragment.glsl    # Fragment shader
├── Cargo.toml           # Dependencies and build config
└── pkg/                 # Build output (generated by wasm-pack)
    ├── n_body_client_bg.wasm
    ├── n_body_client.js
    └── ...
```

### Component Diagram

```mermaid
classDiagram
    class Client {
        -ws: WebSocket
        -renderer: Renderer
        -canvas: HtmlCanvasElement
        -current_state: Option~SimulationState~
        -config: SimulationConfig
        +new(canvas, server_url)
        +start()
        +handle_message(message)
        +render()
        +resize()
        +reset()
        +pause()
        +resume()
        +set_particle_count()
        +set_time_step()
        +set_gravity_strength()
        +set_visual_fps()
        +set_zoom_level()
        +move_camera()
    }

    class Renderer {
        -gl: WebGLRenderingContext
        -program: WebGLProgram
        -vertex_buffer: WebGLBuffer
        -color_buffer: WebGLBuffer
        -camera_offset: Vector2
        -zoom: f32
        +new(canvas) Renderer
        +render(particles)
        +resize(width, height)
        +set_zoom(zoom)
        +move_camera(dx, dy)
        +reset_camera()
    }

    class WebSocket {
        +send_with_str(data)
        +set_onopen()
        +set_onmessage()
        +set_onerror()
        +set_onclose()
        +ready_state()
    }

    Client --> Renderer : contains
    Client --> WebSocket : contains
    Client --> SimulationState : stores

    style Client fill:#e1f5ff
    style Renderer fill:#b3e5fc
    style WebSocket fill:#81d4fa
```

## Core Modules

### lib.rs - Client Entry Point

**Purpose**: Main client struct, WebSocket handling, and state management.

**Client Lifecycle:**

```mermaid
sequenceDiagram
    participant JS as JavaScript
    participant Client as WASM Client
    participant WS as WebSocket
    participant Server as Server

    JS->>Client: new Client(canvas, ws_url)
    Client->>Client: Create Renderer
    Client->>WS: new WebSocket(url)
    Client->>Client: Initialize config

    JS->>Client: client.start()
    Client->>Client: resize()
    Client->>Client: setup_websocket_handlers()

    WS->>Server: Connect
    Server->>WS: 101 Switching Protocols
    WS->>Client: onopen callback
    Client->>JS: updateConnectionStatus(true)

    loop Message Loop
        Server->>WS: ServerMessage
        WS->>JS: onmessage callback
        JS->>Client: handle_message(json)
        Client->>Client: Process message
        alt State message
            Client->>Client: render()
        end
    end
```

**WebSocket Handler Setup:**

```mermaid
graph TB
    Setup[setup_websocket_handlers]

    OnOpen[onopen Handler]
    OnMessage[onmessage Handler]
    OnError[onerror Handler]
    OnClose[onclose Handler]

    Setup --> OnOpen
    Setup --> OnMessage
    Setup --> OnError
    Setup --> OnClose

    OnOpen -->|Call JS| UpdateStatus[updateConnectionStatus<br/>true]
    OnMessage -->|Call JS| HandleMsg[handleWebSocketMessage<br/>json]
    OnError -->|Log| ConsoleError[console.error]
    OnClose -->|Call JS| UpdateDisconnect[updateConnectionStatus<br/>false]

    style Setup fill:#e1f5ff
    style OnOpen fill:#c8e6c9
    style OnMessage fill:#81d4fa
    style OnError fill:#ffccbc
    style OnClose fill:#fff59d
```

**Message Handling Flow:**

```mermaid
graph TB
    Receive[Receive JSON String]
    Parse[Parse ServerMessage]

    CheckType{Message Type}

    State[State Message]
    Stats[Stats Message]
    Config[Config Message]
    Error[Error Message]

    UpdateState[Update current_state]
    CallRender[Call render]
    CallUpdateStats[Call JS updateStats]
    UpdateConfig[Update local config]
    CallUpdateUI[Call JS updateUIFromConfig]
    ShowAlert[Show alert dialog]

    Receive --> Parse
    Parse --> CheckType

    CheckType -->|State| State
    CheckType -->|Stats| Stats
    CheckType -->|Config| Config
    CheckType -->|Error| Error

    State --> UpdateState
    UpdateState --> CallRender

    Stats --> CallUpdateStats

    Config --> UpdateConfig
    UpdateConfig --> CallUpdateUI

    Error --> ShowAlert

    style Receive fill:#a8e6cf
    style Parse fill:#ffd93d
    style State fill:#81d4fa
    style Stats fill:#b3e5fc
    style Config fill:#c8e6c9
    style Error fill:#ffccbc
```

**Configuration Methods:**

| Method | Purpose | Sends to Server |
|--------|---------|-----------------|
| `set_particle_count(usize)` | Change particle count | ✓ UpdateConfig |
| `set_time_step(f32)` | Adjust physics time step | ✓ UpdateConfig |
| `set_gravity_strength(f32)` | Modify gravity constant | ✓ UpdateConfig |
| `set_visual_fps(u32)` | Change render FPS | ✓ UpdateConfig |
| `set_zoom_level(f32)` | Zoom camera in/out | ✓ UpdateConfig |
| `move_camera(f32, f32)` | Pan camera | ✗ Client-only |
| `reset_camera()` | Reset camera position | ✗ Client-only |
| `pause()` | Pause simulation | ✓ Pause |
| `resume()` | Resume simulation | ✓ Resume |
| `reset()` | Reset simulation | ✓ Reset |

---

### renderer.rs - WebGL Rendering Engine

**Purpose**: Manage WebGL context, compile shaders, and render particles.

**Initialization Flow:**

```mermaid
graph TB
    Start[new Renderer]
    GetContext[Get WebGL Context<br/>from canvas]
    CompileShaders[Compile Vertex & Fragment<br/>Shaders]
    LinkProgram[Link Shader Program]
    CreateBuffers[Create Vertex & Color<br/>Buffers]
    GetLocations[Get Attribute &<br/>Uniform Locations]
    SetupGL[Setup GL State<br/>Enable Blend, etc.]
    Return[Return Renderer]

    Start --> GetContext
    GetContext --> CompileShaders
    CompileShaders --> LinkProgram
    LinkProgram --> CreateBuffers
    CreateBuffers --> GetLocations
    GetLocations --> SetupGL
    SetupGL --> Return

    style Start fill:#a8e6cf
    style CompileShaders fill:#ffd93d
    style LinkProgram fill:#ffaaa5
    style CreateBuffers fill:#81d4fa
    style SetupGL fill:#c8e6c9
    style Return fill:#48dbfb
```

**Renderer State:**

```rust
pub struct Renderer {
    gl: WebGlRenderingContext,      // WebGL context
    program: WebGlProgram,           // Compiled shader program
    vertex_buffer: WebGlBuffer,      // Vertex position buffer
    color_buffer: WebGlBuffer,       // Vertex color buffer

    // Attribute locations
    position_attrib: i32,
    color_attrib: i32,

    // Uniform locations
    projection_uniform: Option<WebGlUniformLocation>,
    camera_offset_uniform: Option<WebGlUniformLocation>,
    zoom_uniform: Option<WebGlUniformLocation>,

    // Camera state
    camera_offset: Vector2<f32>,     // Pan offset
    zoom: f32,                        // Zoom level
}
```

**Render Pipeline:**

```mermaid
sequenceDiagram
    participant Client
    participant Renderer
    participant GL as WebGL
    participant GPU

    Client->>Renderer: render(particles)
    Renderer->>Renderer: Extract positions & colors

    Renderer->>GL: clear(COLOR_BUFFER_BIT)
    Renderer->>GL: useProgram(program)

    Renderer->>GL: bindBuffer(vertex_buffer)
    Renderer->>GL: bufferData(positions)
    Renderer->>GL: vertexAttribPointer(position)

    Renderer->>GL: bindBuffer(color_buffer)
    Renderer->>GL: bufferData(colors)
    Renderer->>GL: vertexAttribPointer(color)

    Renderer->>GL: uniform2f(camera_offset)
    Renderer->>GL: uniform1f(zoom)
    Renderer->>GL: uniformMatrix3fv(projection)

    Renderer->>GL: drawArrays(POINTS, 0, count)
    GL->>GPU: Execute shaders
    GPU-->>GL: Rendered frame
```

**Data Preparation:**

```mermaid
graph TB
    Particles[Vec&lt;Particle&gt;]
    ExtractPos[Extract Positions<br/>flatten to f32 array]
    ExtractColor[Extract Colors<br/>flatten to f32 array]
    UploadPos[Upload to GPU<br/>vertex_buffer]
    UploadColor[Upload to GPU<br/>color_buffer]
    Draw[drawArrays<br/>POINTS]

    Particles --> ExtractPos
    Particles --> ExtractColor
    ExtractPos --> UploadPos
    ExtractColor --> UploadColor
    UploadPos --> Draw
    UploadColor --> Draw

    style Particles fill:#e1f5ff
    style ExtractPos fill:#81d4fa
    style ExtractColor fill:#81d4fa
    style UploadPos fill:#ffd93d
    style UploadColor fill:#ffd93d
    style Draw fill:#ff6b6b
```

**Camera Transformations:**

```mermaid
graph LR
    subgraph "Camera System"
        WorldPos[World Position<br/>x, y, z]
        CameraOffset[Camera Offset<br/>pan_x, pan_y]
        Zoom[Zoom Level<br/>scale]
        Projection[Projection Matrix<br/>aspect ratio]
    end

    WorldPos -->|Apply| CameraOffset
    CameraOffset -->|Apply| Zoom
    Zoom -->|Apply| Projection
    Projection -->|Result| ScreenPos[Screen Position]

    style WorldPos fill:#e1f5ff
    style CameraOffset fill:#81d4fa
    style Zoom fill:#ffd93d
    style Projection fill:#c8e6c9
    style ScreenPos fill:#48dbfb
```

**Uniforms:**

| Uniform | Type | Purpose |
|---------|------|---------|
| `u_projection` | mat3 | Projection matrix (aspect ratio) |
| `u_camera_offset` | vec2 | Camera pan offset |
| `u_zoom` | float | Zoom level multiplier |

**Attributes:**

| Attribute | Type | Purpose |
|-----------|------|---------|
| `a_position` | vec3 | Particle world position |
| `a_color` | vec4 | Particle RGBA color |

---

### Shaders

#### Vertex Shader

**Purpose**: Transform particle positions from world space to screen space.

```glsl
attribute vec3 a_position;
attribute vec4 a_color;

uniform mat3 u_projection;
uniform vec2 u_camera_offset;
uniform float u_zoom;

varying vec4 v_color;

void main() {
    // Apply camera offset and zoom
    vec2 pos = (a_position.xy + u_camera_offset) * u_zoom;

    // Apply projection matrix
    vec3 projected = u_projection * vec3(pos, 1.0);

    gl_Position = vec4(projected.xy, 0.0, 1.0);
    gl_PointSize = 2.0;  // Particle size in pixels
    v_color = a_color;
}
```

**Transformation Pipeline:**

```mermaid
graph LR
    WorldPos[World Position<br/>a_position]
    AddOffset[Add Camera Offset<br/>+ u_camera_offset]
    ApplyZoom[Apply Zoom<br/>* u_zoom]
    Project[Apply Projection<br/>* u_projection]
    ClipSpace[Clip Space<br/>gl_Position]

    WorldPos --> AddOffset
    AddOffset --> ApplyZoom
    ApplyZoom --> Project
    Project --> ClipSpace

    style WorldPos fill:#e1f5ff
    style AddOffset fill:#81d4fa
    style ApplyZoom fill:#ffd93d
    style Project fill:#c8e6c9
    style ClipSpace fill:#ff6b6b
```

#### Fragment Shader

**Purpose**: Color each particle pixel.

```glsl
precision mediump float;

varying vec4 v_color;

void main() {
    gl_FragColor = v_color;
}
```

**Per-Fragment Processing:**

```mermaid
graph TB
    Input[Varying v_color<br/>from vertex shader]
    Assign[Assign to gl_FragColor]
    Output[Pixel Color Output]

    Input --> Assign
    Assign --> Output

    style Input fill:#e1f5ff
    style Assign fill:#81d4fa
    style Output fill:#ff6b6b
```

*Note: Simple pass-through shader. Could be extended with particle glow, fade, etc.*

---

## WebGL Rendering

### Rendering Loop

```mermaid
sequenceDiagram
    participant Server
    participant Client
    participant Renderer
    participant GPU

    loop Every visual_fps interval (30 FPS)
        Server->>Client: ServerMessage::State
        Client->>Client: Update current_state
        Client->>Renderer: render(particles)

        Renderer->>GPU: Clear framebuffer
        Renderer->>GPU: Upload vertex data
        Renderer->>GPU: Upload color data
        Renderer->>GPU: Set uniforms
        Renderer->>GPU: Draw points

        GPU->>GPU: Run vertex shader
        GPU->>GPU: Rasterize points
        GPU->>GPU: Run fragment shader
        GPU-->>Client: Display frame
    end
```

### Performance Characteristics

**Rendering Complexity:**

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Data Extraction | O(n) | Flatten positions & colors |
| Buffer Upload | O(n) | Copy to GPU memory |
| Vertex Processing | O(n) | Run vertex shader per particle |
| Rasterization | O(n) | Generate point primitives |
| Fragment Shading | O(p) | p = pixels covered by points |

**GPU Bottlenecks:**

```mermaid
graph LR
    DataPrep[Data Preparation<br/>CPU]
    Upload[Buffer Upload<br/>CPU→GPU]
    VertexShader[Vertex Shader<br/>GPU]
    Rasterization[Rasterization<br/>GPU]
    FragmentShader[Fragment Shader<br/>GPU]

    DataPrep -->|Fast| Upload
    Upload -->|Bandwidth| VertexShader
    VertexShader -->|Fast| Rasterization
    Rasterization -->|Fast| FragmentShader
    FragmentShader -->|Fast| Output[Display]

    style DataPrep fill:#c8e6c9
    style Upload fill:#ffd93d
    style VertexShader fill:#81d4fa
    style Rasterization fill:#81d4fa
    style FragmentShader fill:#81d4fa
```

**Typical Performance:**

- **Up to 15K particles**: 60 FPS on modern GPUs
- **Vertex processing**: ~1-2ms
- **Upload overhead**: ~1-2ms
- **Fragment shading**: < 1ms (small point size)

---

## Browser Integration

### JavaScript ↔ WASM Bridge

**Initialization:**

```javascript
// Load WASM module
import init, { Client } from './pkg/n_body_client.js';

// Initialize WASM runtime
await init();

// Create client instance
const canvas = document.getElementById('canvas');
const client = new Client(canvas, 'ws://localhost:4000/ws');

// Start client
client.start();
```

**JavaScript Callbacks:**

The WASM client calls JavaScript functions for UI updates:

```mermaid
sequenceDiagram
    participant WASM as WASM Client
    participant JS as JavaScript
    participant DOM as DOM Elements

    WASM->>JS: updateConnectionStatus(true)
    JS->>DOM: Update status indicator

    WASM->>JS: handleWebSocketMessage(json)
    JS->>WASM: client.handle_message(json)

    WASM->>JS: updateStats(json)
    JS->>DOM: Update FPS, particle count, etc.

    WASM->>JS: updateUIFromConfig(json)
    JS->>DOM: Update sliders, inputs
```

**Global Functions (defined in JavaScript):**

| Function | Purpose | Called By |
|----------|---------|-----------|
| `updateConnectionStatus(bool)` | Update connection indicator | WASM onopen/onclose |
| `handleWebSocketMessage(string)` | Route message to WASM | WASM onmessage |
| `updateStats(string)` | Update performance stats | WASM (Stats message) |
| `updateUIFromConfig(string)` | Sync UI with config | WASM (Config message) |

**User Input Flow:**

```mermaid
sequenceDiagram
    participant User
    participant DOM as DOM Elements
    participant JS as JavaScript
    participant WASM as WASM Client

    User->>DOM: Adjust slider<br/>(particle count)
    DOM->>JS: oninput event
    JS->>WASM: client.set_particle_count(value)
    WASM->>WASM: Update config
    WASM->>WASM: Send UpdateConfig message

    Note over User,WASM: Server processes, sends back Config message

    WASM->>JS: updateUIFromConfig(json)
    JS->>DOM: Update slider position<br/>(confirmation)
```

### Memory Management

**WASM Memory Layout:**

```mermaid
graph TB
    subgraph "WASM Linear Memory"
        Stack[Stack<br/>Local variables]
        Heap[Heap<br/>Rust allocations]
        Static[Static Data<br/>Constants]
    end

    subgraph "JavaScript Heap"
        JSObjects[JS Objects]
        ClosureData[Closure Data]
        DOMRefs[DOM References]
    end

    subgraph "GPU Memory"
        Buffers[Vertex/Color Buffers]
        Textures[Textures - future]
    end

    WASM -->|Grow| Heap
    WASM <-->|wasm-bindgen| JSObjects
    JSObjects -->|WebGL API| Buffers

    style Stack fill:#e1f5ff
    style Heap fill:#81d4fa
    style JSObjects fill:#c8e6c9
    style Buffers fill:#ffd93d
```

**Ownership:**

- **Rust owns**: Client state, current_state, config
- **JavaScript owns**: DOM elements, event handlers
- **Shared**: WebSocket object (via web-sys bindings)
- **GPU owns**: Vertex/color buffers (uploaded each frame)

### Error Handling

**WASM Error Propagation:**

```mermaid
graph TB
    RustError[Rust Error<br/>Result&lt;T, E&gt;]
    ConvertToJS[Convert to JsValue<br/>wasm-bindgen]
    JSException[JavaScript Exception]
    Catch[try/catch in JS]
    ConsoleLog[console.error]

    RustError -->|map_err| ConvertToJS
    ConvertToJS --> JSException
    JSException --> Catch
    Catch --> ConsoleLog

    style RustError fill:#ff6b6b
    style ConvertToJS fill:#ffd93d
    style JSException fill:#ffaaa5
    style ConsoleLog fill:#c8e6c9
```

**Common Error Scenarios:**

| Error | Source | Handling |
|-------|--------|----------|
| **WebGL not supported** | Browser | Alert user, disable rendering |
| **WebSocket connection failed** | Network | Show "Disconnected" status |
| **Shader compilation error** | GPU/Driver | Log error, fallback rendering |
| **Invalid message format** | Server | Log error, ignore message |
| **Lock failure** | Server | Server sends Error message |

---

## Build Process

### Compilation Pipeline

```mermaid
graph LR
    RustSrc[client/src/*.rs]
    SharedSrc[shared/src/lib.rs]
    WasmPack[wasm-pack build<br/>--target web]

    subgraph "Artifacts"
        WASM[n_body_client_bg.wasm]
        JS[n_body_client.js]
        TS[n_body_client.d.ts]
    end

    RustSrc -->|Compile| WasmPack
    SharedSrc -->|Compile| WasmPack

    WasmPack -->|Generate| WASM
    WasmPack -->|Generate| JS
    WasmPack -->|Generate| TS

    WASM -->|Copy to| ServerPkg[server/pkg/]
    JS -->|Copy to| ServerPkg
    TS -->|Copy to| ServerPkg

    style RustSrc fill:#ff6b6b
    style WasmPack fill:#ffd93d
    style WASM fill:#81d4fa
    style JS fill:#c8e6c9
    style ServerPkg fill:#ffaaa5
```

### wasm-pack Configuration

```toml
[package]
name = "n_body_client"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]  # Compile as dynamic library for WASM

[dependencies]
wasm-bindgen = "0.2"     # Rust ↔ JS bindings
web-sys = { version = "0.3", features = [
    "WebGlRenderingContext",
    "WebGlProgram",
    "WebGlShader",
    "WebSocket",
    # ... more features
]}
```

**Build Command:**

```bash
wasm-pack build --target web --out-dir ../server/pkg
```

**Output Files:**

| File | Purpose |
|------|---------|
| `*.wasm` | Compiled WebAssembly binary |
| `*.js` | JavaScript glue code for loading WASM |
| `*.d.ts` | TypeScript type definitions |
| `package.json` | NPM package metadata |

---

## Future Enhancements

### Potential Improvements

1. **Instanced Rendering**: Use WebGL instancing for better performance
2. **Particle Glow**: Add fragment shader effects
3. **Trail Effects**: Keep history of recent positions
4. **Octree Culling**: Only render visible particles
5. **Level of Detail**: Reduce particle size/quality at distance
6. **Touch Controls**: Mobile-friendly camera controls
7. **Offscreen Rendering**: Use OffscreenCanvas for background updates

### Advanced Rendering

```mermaid
graph TB
    subgraph "Future Rendering Pipeline"
        Particles[Particles]
        Culling[Frustum Culling<br/>Octree]
        LOD[Level of Detail<br/>Distance-based]
        Instancing[Instanced Rendering]
        PostProcess[Post-Processing<br/>Bloom, etc.]
        Output[Display]
    end

    Particles --> Culling
    Culling --> LOD
    LOD --> Instancing
    Instancing --> PostProcess
    PostProcess --> Output

    style Particles fill:#e1f5ff
    style Culling fill:#81d4fa
    style LOD fill:#ffd93d
    style Instancing fill:#ff6b6b
    style PostProcess fill:#c8e6c9
```

---

## Related Pages

- **[Architecture Overview](Architecture)** - System architecture
- **[Communication Protocol](Communication-Protocol)** - WebSocket messages
- **[Server Components](Server-Components)** - Server details
- **[Development Guide](Development-Guide)** - Building and running

---

[← Back to Home](Home)
